% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitAssayDiff.R
\name{fitAssayDiff}
\alias{fitAssayDiff}
\alias{fitAssayDiff,SummarizedExperiment-method}
\title{Detect Differential ChIP Signal}
\usage{
fitAssayDiff(x, ...)

\S4method{fitAssayDiff}{SummarizedExperiment}(
  x,
  assay = "counts",
  design = NULL,
  coef = NULL,
  lib.size = "totals",
  method = c("qlf", "lt"),
  norm = c("none", "TMM", "RLE", "TMMwsp", "upperquartile"),
  groups = NULL,
  fc = 1,
  lfc = log2(fc),
  asRanges = FALSE,
  ...
)
}
\arguments{
\item{x}{a SummarizedExperiment object}

\item{...}{Passed to \link[edgeR]{calcNormFactors}, \link[edgeR]{estimateDisp}
and \link[edgeR]{glmQLFit} when method = "qlf".
If method = "lt", instead passed to \link[limma]{lmFit}, \link[limma]{treat},
\link[limma]{eBayes}}

\item{assay}{The assay to use for analysis}

\item{design}{The design matrix to use for analysis}

\item{coef}{The required column from the design matrix}

\item{lib.size}{The column within the colData element which contains the
library size information. If set to NULL, column summaries will be used.}

\item{method}{the analytic method to be used. Can be 'qlf' which will fit
counts using the \link[edgeR]{glmQLFit} strategy , or 'lt' which fits the
\link[limma:eBayes]{limma-trend} model on logCPM, or pre-processed logCPM
values}

\item{norm}{The normalisation strategy to use when running the
glmQLF models. The value 'none' relies solely on library-size normalisation,
and is the default. All methods available in \link[edgeR]{calcNormFactors}
are implemented. Ignored when using method = "lt"}

\item{groups}{character(1) If a column name is supplied here, group-based
normalisation will be applied to GLM models treating data in this column
as a grouping factor. Ignored when using method = "lt"}

\item{fc, lfc}{Thresholds passed to \link[limma]{treat} or
\link[edgeR]{glmTreat}}

\item{asRanges}{logical(1). By default, the returned object will be a
\code{SummarizedExperiment} object with the results added to the \code{rowData}
element. Setting \code{asRanges = TRUE} will only return the GRanges object from
this element}
}
\value{
A SummarizedExperiment object with results set as the \code{rowData} element.
Any existing columns not contained in the differential ChIP results will be
retained.
Results from testing will contain logCPM, logFC, PValue and the t/F
statistic as appropriate, along with an FDR-adjusted p-value
}
\description{
Detect differential ChIP signal using one of many approaches
}
\details{
Starting with a SummarizedExperiment object this function fits either a
\link[edgeR]{glmQLFit} model to count data, or the
\link[limma:eBayes]{limma-trend} model to logCPM data.

If fitting Generalised Linear Models via glmQLFit, options for normalisation
are "none", which normalises to library size. Existing library sizes are
commonly found in the "totals" column of the colData element and this is
attempted by default. All methods provided in \link[edgeR]{calcNormFactors}
are also implemented, with the added possibility of normalising within groups
instead of across the entire dataset. To enable this, the column with the
grouping factor is expected to be in the colData element and is simply
called by column name.
No normalisation is applied when using the limma-trend model, as this allows
for previous normalisation strategies to be performed on the data.

Normalising to ChIP Input samples, or using offsets is not yet implemented.

Either range-based hypothesis testing is implemented using
\link[edgeR]{glmTreat} or \link[limma]{treat}. Setting fc to 1 (or lfc to 0)
will default to a point-based null hypothesis, equivalent to either
\link[edgeR]{glmQLFTest} (method = "qlf") or
\link[limma]{eBayes} (method = "lt").

It should also be noted that this is primarily a convenience function and
if requiring intermediate output from any setps, then these can be run
individually as conventionally specified.
}
\examples{
nrows <- 200; ncols <- 6
counts <- matrix(runif(nrows * ncols, 1, 1e4), nrows)
colnames(counts) <- paste0("Sample_", seq_len(ncols))
df <- DataFrame(treat = c("A", "A", "A", "B", "B", "B"))
df$treat <- as.factor(df$treat)
se <- SummarizedExperiment(
  assays = SimpleList(counts = counts), colData = df
)
X <- model.matrix(~treat, colData(se))
se <- fitAssayDiff(se, design = X, lib.size = NULL)
rowData(se)


}
